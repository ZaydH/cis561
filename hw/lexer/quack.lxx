/* Scanner for "C" assignment statements... sort of. */
/* Compile: reflex --bison-cc --bison-locations --header-file reflexexample9.lxx */
/* Compile: bison -d flexexample9.yxx */

%top{
#include <sstream>

#include "quack.tab.hxx"  /* Generated by bison. */
#include "Messages.h"
%}

%option bison-cc bison-locations noyywrap
%option namespace=yy lexer=Lexer lex=yylex

  /* Start condition used to handle block comments.
   *
   * Based on the description on stack overflow:
   * https://stackoverflow.com/questions/2130097/difficulty-getting-c-style-comments-in-flex-lex
   *
   * Full documentation:
   * http://dinosaur.compilertools.net/flex/flex_11.html
   *
   * RE/flex documentation:
   * https://www.genivia.com/doc/reflex/html/#reflex-states
   */
%{
static std::stringstream ss;
%}
%x BLOCK_COMMENT LINE_COMMENT BLOCK_STRING SIMPLE_STRING

%%
"/*" { start(BLOCK_COMMENT); }
<BLOCK_COMMENT>{
<<EOF>>      { report::error("Unexpected EOF in block comment at line "
                             + std::to_string(lineno()));
               start(INITIAL); }
  /* INITIAL Reserved word for default state. */
"*/"         { start(INITIAL); }
\n           /* Do Nothing */
}
"//" { start(LINE_COMMENT); }
  /* INITIAL Reserved word for default state. */
<LINE_COMMENT><<EOF>>|\n   { start(INITIAL); }
  /* Anything beside a new line */
<BLOCK_COMMENT,LINE_COMMENT>. /* Do Nothing */

  /**
   * Block string
   */
  /* ToDO Fill-in block string */
\"\"\" { start(BLOCK_STRING); ss.str("");/*clear the stringstream */ }
<SIMPLE_STRING,BLOCK_STRING><<EOF>>     { report::error("Invalid EOF in string."); }
<BLOCK_STRING>{
\"\"\"  { start(INITIAL);
          yylval.str = const_cast<char*>(ss.str().c_str());
          return yy::parser::token::STRING;
        }
.|\n    { ss << text(); }
}

  /**
   * Simple string (i.e., single quote only)
   *
   * Based on: https://stackoverflow.com/questions/5418181/flex-lex-encoding-strings-with-escaped-characters
   */
  /** ToDo Fill-in simple string */
\" { start(SIMPLE_STRING); ss.str("");/*clear the stringstream */ }
<SIMPLE_STRING>{
[^\\"\n<<EOF>>]*   { ss << text(); }
\\0         { ss << '\0'; }
\\b         { ss << '\b'; }
\\t         { ss << '\t'; }
\\n         { report::error("Invalid newline in simple string at line" + std::to_string(lineno())
                            + ", column " + std::to_string(columno())); }
\\r         { ss << '\r'; }
\\f         { ss << '\f'; }
\\\"        { ss << '\"'; }
\\\\        { ss << '\\'; }
\\.         { report::error("Unknown escape character at line" + std::to_string(lineno())
                            + ", column " + std::to_string(columno())); }
  /* INITIAL Reserved word for default state. */
\" { start(INITIAL);
     yylval.str = const_cast<char*>(ss.str().c_str());
     return yy::parser::token::STRING;
   }
}



   /* Punctuation and keywords don't need values. */
:    {  return yy::parser::token::COLON; }
;    {  return yy::parser::token::SEMICLN; }

\+   {  return yy::parser::token::PLUS; }
\*   {  return yy::parser::token::TIMES; }
\-   {  return yy::parser::token::MINUS; }
\/   {  return yy::parser::token::DIV; }
\(   {  return yy::parser::token::LPAREN; }
\)   {  return yy::parser::token::RPAREN; }
\{   {  return yy::parser::token::LCURLY; }
\}   {  return yy::parser::token::RCURLY; }
>    {  return yy::parser::token::GT; }
<    {  return yy::parser::token::LT; }
>=   {  return yy::parser::token::GEQ; }
<=   {  return yy::parser::token::LEQ; }
==   {  return yy::parser::token::EQ; }

and {  return yy::parser::token::AND; }
or  {  return yy::parser::token::OR; }
not {  return yy::parser::token::NOT; }

class   {  return yy::parser::token::CLASS; }
extends {  return yy::parser::token::EXTENDS; }
def     {  return yy::parser::token::DEF; }
,       {  return yy::parser::token::PARAM_SEP; }
return  {  return yy::parser::token::RETURN; }
while   {  return yy::parser::token::WHILE; }
if      {  return yy::parser::token::IF; }
elif    {  return yy::parser::token::ELIF; }
else    {  return yy::parser::token::ELSE; }

typecase      { return yy::parser::token::TYPECASE; }
Nothing       { return yy::parser::token::NOTHING; }
none          { return yy::parser::token::NONE; }

 /* Integer literals and identifiers do need semantic values,
  * the integer value or the identifier text.
  */
false|true  { yylval.boolean = ((strcmp(text(), "true") == 0) ? true : false); return yy::parser::token::BOOLEAN; }
[[:digit:]]+  { yylval.num = atoi(text());   return yy::parser::token::NUMBER; }
[[:alnum:]_]+ { yylval.str = strdup(text()); return yy::parser::token::IDENT; }

=   { yylval.str = strdup(text()); return yy::parser::token::GETS; }


[ \n]          {}
.  {
    report::error("Unexpected character '" + std::string(text()) + "'" +
       " at line " + std::to_string(lineno()) +
       ", column " + std::to_string(columno()));
   }

%%

