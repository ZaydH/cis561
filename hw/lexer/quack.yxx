/* Parser to convert "C" assignments to lisp using Bison in C. */
/* Demonstrates Bison C++ interface with %skeleton "lalr1.cc" */
/* Compile: bison -d flexexample9.yxx */

%skeleton "lalr1.cc"
%require  "3.0"

/* The following section "code requires" finds its way into
 * quack.tab.hxx, so definitions and declarations in this block
 * can be imported into the lexer.
 */
%code requires{
  namespace yy {
    class Lexer;  /* Generated by reflex with namespace=yy lexer=Lexer */
  }

  #include <vector>

  #include "ASTNode.h" // Abstract syntax tree
  #include "QClass.h"  // Quack Class
  #include "ASTAssn.h"
}

%locations
%define parse.trace

%parse-param { yy::Lexer& lexer }  /* Construct parser object with lexer */
%parse-param { AST::Program** root }  /* To pass AST root back to driver */

%code{
    #include "lex.yy.h"
    #undef yylex
    /* Within bison's parse() we should invoke lexer.yylex(), not the global yylex() */
    #define yylex lexer.yylex
    void dump(AST::ASTNode* n);
    char* convert_string_to_char_ptr(const std::string &str);

}

%union {
    int   num;
    bool  boolean;
    char* str;
    AST::Program* program;
    AST::ASTNode* node;
    AST::ASTNode* int_node;
    AST::ASTNode* bool_node;
    AST::AssnVar* assn;
    AST::NamedObject* object;
    std::vector<AST::ASTNode*>* object_params;
    // Methods used for classes and methods so need explicit types
    AST::QuackClass* q_class;
    AST::QuackClass::Container* classes;
    AST::QuackClass::Method* method;
    AST::QuackClass::Method::Container* methods;
    AST::QuackClass::Parameter* param;
    AST::QuackClass::Parameter::Container* params;
    // block needs a more explicit type to use the 'append' method
    AST::Block* block;
}

// The following token values are actually used
%token <str> IDENT
%token <str> STRING
%token <num> NUMBER
%token <boolean> BOOLEAN

// The following tokens don't need values
%token LINE_COMMENT_START
%token CLASS EXTENDS INT_CLASS BOOL_CLASS STRING_CLASS OBJ_CLASS
%token DEF COMMA RETURN
%token IF ELIF ELSE
%token WHILE

%token TYPECASE
%token NOTHING NONE
%token COLON SEMICLN
%token PERIOD
%token AND OR NOT
%token LEQ GEQ GT LT EQ
%token PLUS MINUS TIMES DIV GETS
%token LPAREN RPAREN
%token LCURLY RCURLY

// Abstract syntax tree nodes
%type <program> program
%type <node> expr stmt
%type <node> i_leaf b_leaf
%type <bool_node> b_expr
%type <int_node>  i_expr
%type <block> block code_block return_stmt if_alternatives
%type <node> ifstmt
%type <node> while

%type <str> method_name return_type
%type <str> new_class_name super_class inherited_class all_class_names

%type <assn> assignment
%type <object> assn_object leaf_object
%type <str> object_name object_type
%type <object_params> object_params object_params_set

%type <q_class> q_class class_sig
%type <classes> classes
%type <method> method
%type <methods> methods
%type <param> param
%type <params> params param_set
%type <str> param_name param_type


// Precedence.  We are using an ambiguous expression grammar
// for compactness.  We declare operator precedence from lowest
// to highest, with associativity, e.g., MINUS is left_ associative
// so a-b-c is (a-b)-c and not a-(b-c).

%precedence NOT  // No direction since unary operator
%left  MINUS PLUS
%left  TIMES DIV
%left  GT GEQ LT LEQ
%left  EQ
%left  AND
%left  OR
%%

/* Root of the grammar is "program".  A program
 * is a non-empty sequence of assignments or expressions.
 */
program: classes block  { *root = new AST::Program($1, $2); } ;

/**
 * Token used to represent the set of ALL valid classes.  It is not the set
 * of valid class names.
 */
all_class_names: INT_CLASS    { $$ = convert_string_to_char_ptr("Int"); }
               | BOOL_CLASS   { $$ = convert_string_to_char_ptr("Boolean"); }
               | STRING_CLASS { $$ = convert_string_to_char_ptr("String"); }
               | OBJ_CLASS    { $$ = convert_string_to_char_ptr("Obj"); }
               | IDENT        { $$ = $1; }
               ;

/**
 * Default structure for all parameters.  This is used throughout the program.
 */
params: param_set          { $$ = $1; }
      | %empty /* No parameters */ { $$ = new AST::QuackClass::Parameter::Container(); }
      ;
param_set: param_set COMMA param { $1->emplace($3->name_, $3); }
         | param    { $$ = new AST::QuackClass::Parameter::Container();
                       $$->emplace($1->name_, $1);
                    }
         ;
param: param_name COLON param_type { $$ = new AST::QuackClass::Parameter($1, $3); } ;
param_name: IDENT { $$=$1; } ;
param_type: all_class_names { $$=$1; };

/**
 * Definition of Quack Classes.
 */
classes: classes q_class { $1->emplace($2->name_, $2); $$=$1; }
       | %empty /* no classes */ { $$ = new AST::QuackClass::Container(); }
       ;
q_class: CLASS class_sig LCURLY block methods RCURLY
                { $2->add_constructor($4); $2->add_methods($5); $$=$2; }
       ;

class_sig: new_class_name LPAREN params RPAREN super_class
                { $$ = new AST::QuackClass($1, $5, $3); }
         ;
new_class_name: IDENT { $$ = $1; } ;
super_class: EXTENDS inherited_class { $$ = $2; }
           // ToDo Convert from nullptr for obj inheritance
           | %empty /* Inherits Obj */ { $$ = convert_string_to_char_ptr("Obj"); }
           ;
// ToDo Check if can inherit INT and BOOLEAN
inherited_class: all_class_names { $$ = $1; } ;

/**
 * Definition of class methods.
 */
methods: methods method { $1->emplace($2->name_, $2); $$=$1; }
       | %empty /* no method */ { $$ = new AST::QuackClass::Method::Container(); }
       ;
method: DEF method_name LPAREN params RPAREN COLON return_type LCURLY block RCURLY
           { $$ = new AST::QuackClass::Method($2, $4, $7, $9); }
      ;
method_name: IDENT { $$ = $1; } ;
return_type: all_class_names { $$ = $1; } ;

/* Standard recursive definition for a non-empty sequence. */
block: %empty /* empty */ { $$ = new AST::Block(); }
     | code_block { $$ = $1; }
     ;

code_block: code_block stmt { $1->append($2); $$ = $1; }
          | stmt       { $$ = new AST::Block(); $$->append($1); }
          // ToDo fix return
          | code_block return_stmt { $1->append($2); $$ = $1; }
          | return_stmt { $$ = $1; }
          ;
return_stmt: RETURN stmt { $$ = new AST::Block(); $$->append(new AST::Return($2)); }
stmt: assignment SEMICLN { $$ = $1; }
    | expr SEMICLN { $$ = $1; }
    | ifstmt { $$ = $1; }
    | while  { $$ = $1; }
    ;

ifstmt: IF LPAREN b_expr RPAREN LCURLY block RCURLY if_alternatives
                { $$ = new AST::If(*$3, *$6, *$8); }
      ;

if_alternatives:   %empty /* empty */  { $$ = new AST::Block(); };
if_alternatives:   ELSE LCURLY block RCURLY   { $$ = $3; };
if_alternatives:   ELIF LPAREN b_expr RPAREN LCURLY block RCURLY if_alternatives
             {  $$ = new AST::Block();
                $$->append(new AST::If(*$3, *$6, *$8));
             };

while: WHILE LPAREN b_expr RPAREN LCURLY block RCURLY
            { $$ = new AST::While(*$3, *$6); }
     ;

// ToDo When Taking an Object with Type, Ensure new variable
assignment: assn_object COLON object_type GETS expr
                { $$ = new AST::AssnVar($1, $5, $3); }
          | assn_object GETS expr { $$ = new AST::AssnVar($1, $3); }
          ;
object_type: all_class_names;
assn_object: object_name PERIOD assn_object
                { $$ = new AST::ObjectCall($1, $3); }
           | method_name LPAREN object_params_set RPAREN PERIOD assn_object
                { $$ = new AST::ObjectMethodCall($1, $3, $6); }
           | object_name { $$ = new AST::NamedObject($1); }
           ;
object_name: IDENT { $$=$1; };
object_params_set: %empty /* no params */ { $$ = new std::vector<AST::ASTNode*>(); }
                 | object_params { $$ = $1; }
                 ;
object_params: object_params COMMA expr { $1->emplace_back($3); $$=$1; }
             | expr { $$ = new std::vector<AST::ASTNode*>(); $$->emplace_back($1); }
             ;

expr: i_expr { $$=$1; }
    | b_expr { $$=$1; }
    | STRING { $$ = new AST::StringConst($1); }
    ;

b_expr: NOT b_expr           { $$ = new AST::Not(*$2); dump($$); }
      | b_expr AND b_expr    { $$ = new AST::And(*$1, *$3); dump($$); }
      | b_expr OR b_expr     { $$ = new AST::Or(*$1, *$3); dump($$); }
      | i_expr GT i_expr     { $$ = new AST::GT(*$1, *$3); dump($$); }
      | i_expr GEQ i_expr    { $$ = new AST::GEQ(*$1, *$3); dump($$); }
      | i_expr LT i_expr     { $$ = new AST::LT(*$1, *$3); dump($$); }
      | i_expr LEQ i_expr    { $$ = new AST::LEQ(*$1, *$3); dump($$); }
      | LPAREN b_expr RPAREN { $$ = $2; }
      // ToDo verify Equality is correctly handling types
      // ToDo ensure equality supports strings
      | b_expr EQ b_expr     { $$ = new AST::EQ(*$1, *$3); dump($$); }
      | i_expr EQ i_expr     { $$ = new AST::EQ(*$1, *$3); dump($$); }
      | b_leaf               { $$ = $1; }
      ;

i_expr: MINUS i_expr         { $$ = new AST::Negate( *$2 ); dump($$); }
      | i_expr PLUS i_expr   { $$ = new AST::Plus( *$1, *$3 ); dump($$); }
      | i_expr MINUS i_expr  { $$ = new AST::Minus( *$1, *$3 ); dump($$); }
      | i_expr TIMES i_expr  { $$ = new AST::Times( *$1, *$3 ); dump($$); }
      | i_expr DIV i_expr    { $$ = new AST::Div( *$1, *$3 ); dump($$); }
      | LPAREN i_expr RPAREN { $$ = $2; }
      | i_leaf               { $$ = $1; }
      | error i_leaf     { $$ = $2; }
      ;

// ToDo Add object method

// ToDO change the leaves to support objects
i_leaf: NUMBER { $$ = new AST::IntConst($1); dump($$); }
      | leaf_object  { $$ = $1; }
      ;
b_leaf: BOOLEAN { $$ = new AST::BoolConst($1); dump($$); }
//      // ToDo Add feature for Bool leaf
//      | leaf_object  { $$ = $1; }
      ;
leaf_object: object_name PERIOD leaf_object
                { $$ = new AST::ObjectCall($1, $3); }
           | object_name
                { $$ = new AST::NamedObject($1); }
           | method_name LPAREN object_params_set RPAREN PERIOD leaf_object
                { $$ = new AST::ObjectMethodCall($1, $3, $6); }
           | method_name LPAREN object_params_set RPAREN
                { $$ = new AST::ObjectMethodCall($1, $3); }
           ;

//class_field: object_name PERIOD method_name

%%
#include "Messages.h"

void yy::parser::error(const location_type& loc, const std::string& msg)
{
  report::error_at(loc, msg);
}

void dump(AST::ASTNode* n) {
    // std::cout << "*** Building: " << n->str() << std::endl;
}

char* convert_string_to_char_ptr(const std::string &str) {
    return const_cast<char*>(str.c_str());
}

