/* Parser to convert "C" assignments to lisp using Bison in C. */
/* Demonstrates Bison C++ interface with %skeleton "lalr1.cc" */
/* Compile: bison -d flexexample9.yxx */

%skeleton "lalr1.cc"
%require  "3.0"

/* The following section "code requires" finds its way into
 * quack.tab.hxx, so definitions and declarations in this block
 * can be imported into the lexer.
 */
%code requires{
  namespace yy {
    class Lexer;  /* Generated by reflex with namespace=yy lexer=Lexer */
  }

  #include "tree_node.h"
}

%locations
%define parse.trace

%parse-param { yy::Lexer& lexer }  /* Construct parser object with lexer */
%parse-param { ASTNode** root }  /* To pass AST root back to driver */

%code{
    #include "lex.yy.h"
    #undef yylex
    /* Within bison's parse() we should invoke lexer.yylex(), not the global yylex() */
    #define yylex lexer.yylex
    char* str_to_char_ptr(const std::string &str);
}

%union {
    char* str;
    ASTNode* node;
}

%token D_QUOTE_LEFT S_QUOTE_LEFT D_QUOTE_RIGHT S_QUOTE_RIGHT

// The following token values are actually used
%token <str> STRING

// Abstract Syntax Tree Nodes
%type <node> program body leaf

%%

/* Root of the grammar is "program".  A program
 * is a non-empty sequence of assignments or expressions.
 */
program: %empty  { *root = new ASTNode(str_to_char_ptr("")); }
       | body    { $$ = $1; }
       ;

body: body leaf { $1->next_=$2; $$ = $1; }
    | leaf      { $$ = $1; }
    ;

leaf: D_QUOTE_LEFT { $$ = new ASTNode(str_to_char_ptr("&ldquo;")); }
    | D_QUOTE_RIGHT { $$ = new ASTNode(str_to_char_ptr("&rdquo;")); }
    | S_QUOTE_LEFT { $$ = new ASTNode(str_to_char_ptr("&lquo;")); }
    | S_QUOTE_RIGHT { $$ = new ASTNode(str_to_char_ptr("&rquo;")); }
    | STRING { $$ = new ASTNode($1); }
    ;

%%
#include "Messages.h"

void yy::parser::error(const location_type& loc, const std::string& msg)
{
  report::error_at(loc, msg);
}

char* str_to_char_ptr(const std::string &str) {
    return const_cast<char*>(str.c_str());
}
