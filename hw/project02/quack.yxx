/* Parser to convert "C" assignments to lisp using Bison in C. */
/* Demonstrates Bison C++ interface with %skeleton "lalr1.cc" */
/* Compile: bison -d flexexample9.yxx */

%skeleton "lalr1.cc"
%require  "3.0"

/* The following section "code requires" finds its way into
 * quack.tab.hxx, so definitions and declarations in this block
 * can be imported into the lexer.
 */
%code requires{
  namespace yy {
    class Lexer;  /* Generated by reflex with namespace=yy lexer=Lexer */
  }

  #include <vector>

  #include "ASTNode.h" // Abstract syntax tree
  #include "quack_program.h"
  #include "quack_classes.h"
}

%locations
%define parse.trace

%parse-param { yy::Lexer& lexer }  /* Construct parser object with lexer */
%parse-param { Quack::Program* root }  /* Pass the quack program back to the tool */

%code{
    #include "lex.yy.h"
    #undef yylex
    /* Within bison's parse() we should invoke lexer.yylex(), not the global yylex() */
    #define yylex lexer.yylex

}

%union {
    int   num;
    bool  boolean;
    char* str;
    Quack::Program* program;

    Quack::Class::Container* classes;
    Quack::Class* q_class;
    Quack::Method::Container* methods;
    Quack::Method* method;


    AST::Block*block;
}

// The following token values are actually used
%token <str> IDENT
%token <str> STRING_LIT
%token <num> INT_LIT
%token <boolean> BOOLEAN

// The following tokens don't need values
%token CLASS EXTENDS
%token DEF COMMA RETURN
%token IF ELIF ELSE
%token WHILE

%token TYPECASE

// Abstract syntax tree nodes
%type <program> program
%type <classes> classes

%type <q_class> q_class
%type <methods> methods
%type <method> method
%type <str> var_type


%type <block> block

%type <str> super_class

// Precedence.  We are using an ambiguous expression grammar
// for compactness.  We declare operator precedence from lowest
// to highest, with associativity, e.g., MINUS is left_ associative
// so a-b-c is (a-b)-c and not a-(b-c).

%precedence NOT  // No direction since unary operator
%left  '-' '+'
%left  '*' '/'
%left  ATLEAST ATMOST '>' '<'
%left  EQUALS
%left  AND
%left  OR
%left  '='
%%

/* Root of the grammar is "program".  A program
 * is a non-empty sequence of assignments or expressions.
 */
program: classes block  { root = new Quack::Program($1, $2); }
       ;

classes: q_class classes  { $2->add($1);
                            $$=$2;
                          }
       | %empty           { $$ = Quack::Class::Container::singleton(); }
       ;

q_class: CLASS IDENT '(' input_params ')' super_class '{' block methods '}'
            { $$ = new Quack::Class($2, $6, $8, $9); }
       ;
input_params: %empty {}
            | input_params ',' param {}
            | param {}
param: IDENT            {}
     | IDENT ':' IDENT  {}
     ;

super_class: EXTENDS IDENT { $$ = $2; }
           | %empty        { $$ = strdup(""); }
           ;

methods: method methods {
                          $2->add($1);
                          $$ = $2;
                        }
       | %empty { $$ = new Quack::Method::Container(); }
       ;
method: DEF IDENT '(' input_params ')' var_type '{' block '}'
           { $$ = new Quack::Method($2, $6, $8); }
      ;
var_type: ':' IDENT      { $$ = $2; }
        | %empty         { $$ = strdup(""); }
        ;

block  : %empty             { $$ = new AST::Block(); }
       ;
%%
#include "Messages.h"

void yy::parser::error(const location_type& loc, const std::string& msg)
{
  report::error_at(loc, msg);
}
