\documentclass[11pt]{report}

\usepackage{listings}

\title{Lazy Evaluation in Haskell}
\subtitle{CIS561 Graduate Report}
\author{Zayd Hammoudeh}

\begin{document}

A language's evaluation semantics codify a set of rules that describe how expressions are evaluated.~\cite{hoover:Notes}  Non-functional programming languages almost exclusively follow \textit{strict}, also known as \textit{greedy} or \textit{eager}, semantic rules where expressions are evaluated immediately after being bound to a variable.  Therefore, the order of operations is implicitly defined by the structure of the code written by the programmer.

In contrast, many modern functional programming languages utilize \textit{non-strict}, also known as lazy, semantics.  This style of evaluation has two basic goals:



    Intuitively, this eager paradigm aligns with how work is performed in the real world.  A worker is told to do a job; the worker does what he is instructed. When that job is completed, the worker is assigned the next job and so forth. In this example, the worker is not thinking whether the work being performed ends up being useful.  His only concern is doing the work he is assigned.  Clearly, this can lead to waste.

    Contrast this eager strategy with a lazy evaluator, which only performs an evaluation step when necessary.!\cite{Henderson:1976}. Perhaps the simplest form of lazy evaluation is a Boolean short circuit operator.  Take the case of {\tt AND}.  If the first operand is False, the value of the second operand is irrelevant, and its evaluation can be lazily skipped.

    Consider the sample function shown in Figure~\ref{lst:Square}.  Depending on the value of parameter ``{\tt x}'', parameter ``{\tt y}'' is either needed once or not at all.  In either case, an eager evaluator copies the value (or reference) to ``{\tt y}'' onto the stack.

    \begin{figure}
        \begin{listings}[python]
            def f(x, y):
            if x == 1:
            return 0
            else:
            return y * y
        \end{listings}
        \caption{Simple procedure that optionally returns the square of an input parameter}\label{lst:Square}
    \end{figure}

    In addition, since eager evaluators create objects as soon as the object is defined, they introduce challenges when the object size is initially unknowable.  For example, consider the mathematical concept of an infinite sequence of the form $i = 1, 2,\ldots$.

    The first lazy evaluator, presented by Henderson and Morris,~\cite{Henderson:1976}, had two primary goals:
    \begin{enumerate}
        \item Perform an evaluation step only when necessary
        \item Never perform the same step twice.
    \end{enumerate}
\noindent


\end{document}

